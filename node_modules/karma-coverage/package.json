{
  "_args": [
    [
      "karma-coverage@https://registry.npmjs.org/karma-coverage/-/karma-coverage-0.4.1.tgz",
      "/home/lmacvean/workarea/seventag"
    ]
  ],
  "_from": "karma-coverage@>=0.4.1 <0.5.0",
  "_id": "karma-coverage@0.4.1",
  "_inCache": true,
  "_location": "/karma-coverage",
  "_phantomChildren": {
    "abbrev": "1.0.7",
    "amdefine": "1.0.0",
    "async": "1.5.2",
    "estraverse": "1.9.3",
    "fileset": "0.2.1",
    "js-yaml": "3.5.3",
    "mkdirp": "0.5.1",
    "nopt": "3.0.6",
    "once": "1.3.3",
    "optionator": "0.5.0",
    "resolve": "1.1.7",
    "wordwrap": "0.0.3"
  },
  "_requested": {
    "name": "karma-coverage",
    "raw": "karma-coverage@https://registry.npmjs.org/karma-coverage/-/karma-coverage-0.4.1.tgz",
    "rawSpec": "https://registry.npmjs.org/karma-coverage/-/karma-coverage-0.4.1.tgz",
    "scope": null,
    "spec": "https://registry.npmjs.org/karma-coverage/-/karma-coverage-0.4.1.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "#DEV:/"
  ],
  "_resolved": "https://registry.npmjs.org/karma-coverage/-/karma-coverage-0.4.1.tgz",
  "_shasum": "2bd0a2f2991ae15f54a9a7037b4d57a722dbda83",
  "_shrinkwrap": null,
  "_spec": "karma-coverage@https://registry.npmjs.org/karma-coverage/-/karma-coverage-0.4.1.tgz",
  "_where": "/home/lmacvean/workarea/seventag",
  "author": {
    "email": "ryushi@gmail.com",
    "name": "SATO taichi"
  },
  "bugs": {
    "url": "https://github.com/karma-runner/karma-coverage/issues"
  },
  "contributors": [
    {
      "name": "Timo Tijhof",
      "email": "krinklemail@gmail.com"
    },
    {
      "name": "Aymeric Beaumet",
      "email": "aymeric@beaumet.me"
    },
    {
      "name": "Tim Kang",
      "email": "timkang@ucla.edu"
    },
    {
      "name": "Maksim Ryzhikov",
      "email": "rv.maksim@gmail.com"
    },
    {
      "name": "Nick Malaguti",
      "email": "nmalaguti@palantir.com"
    },
    {
      "name": "Allen Bierbaum",
      "email": "abierbaum@gmail.com"
    },
    {
      "name": "Matt Winchester",
      "email": "m_winche@yahoo.com"
    },
    {
      "name": "Wei Kin Huang",
      "email": "weikin.huang04@gmail.com"
    },
    {
      "name": "Douglas Duteil",
      "email": "douglasduteil@gmail.com"
    },
    {
      "name": "Nick Matantsev",
      "email": "nick.matantsev@gmail.com"
    },
    {
      "name": "Petar Manev",
      "email": "petar.manev2010@gmail.com"
    },
    {
      "name": "Robin Böhm",
      "email": "robinboehm@googlemail.com"
    },
    {
      "name": "Ron Derksen",
      "email": "ron.derksen@informaat.nl"
    },
    {
      "name": "Sahat Yalkabov",
      "email": "sakhat@gmail.com"
    },
    {
      "name": "Tanjo, Hiroyuki",
      "email": "expheno@gmail.com"
    },
    {
      "name": "Taylor Hakes",
      "email": "taylor@taylorhakes.com"
    },
    {
      "name": "Friedel Ziegelmayer",
      "email": "dignifiedquire@gmail.com"
    },
    {
      "name": "Tom Kirkpatrick",
      "email": "tom@systemseed.com"
    },
    {
      "name": "Vincent Lemeunier",
      "email": "vincent.lemeunier+git@gmail.com"
    },
    {
      "name": "Yusuke Suzuki",
      "email": "utatane.tea@gmail.com"
    },
    {
      "name": "aprooks",
      "email": "alexander.prooks@gmail.com"
    },
    {
      "name": "piecyk",
      "email": "piecyk@gmail.com"
    },
    {
      "name": "Chris Gladd",
      "email": "chris.m.gladd@gmail.com"
    },
    {
      "name": "Dmitry Petrov",
      "email": "dpetroff@gmail.com"
    },
    {
      "name": "Greg Varsanyi",
      "email": "gvarsanyi@gmail.com"
    },
    {
      "name": "Joseph Connolly",
      "email": "joec@avinetworks.com"
    },
    {
      "name": "Joshua Appelman",
      "email": "jappelman@xebia.com"
    },
    {
      "name": "Julie",
      "email": "ju.ralph@gmail.com"
    },
    {
      "name": "Kyle Welsby",
      "email": "kyle@mekyle.com"
    },
    {
      "name": "Maciej Rzepiński",
      "email": "maciej.rzepinski@gmail.com"
    },
    {
      "name": "Mark Ethan Trostler",
      "email": "mark@zzo.com"
    },
    {
      "name": "Michael Stramel",
      "email": "m.stramel89@gmail.com"
    }
  ],
  "dependencies": {
    "dateformat": "^1.0.6",
    "istanbul": "^0.3.15",
    "minimatch": "^2.0.8",
    "source-map": "^0.4.2"
  },
  "description": "A Karma plugin. Generate code coverage.",
  "devDependencies": {
    "chai": "^2.3.0",
    "eslint": "^0.22.1",
    "eslint-config-standard": "^2.0.1",
    "eslint-plugin-react": "^2.5.0",
    "grunt": "^0.4.1",
    "grunt-bump": "^0.3.1",
    "grunt-conventional-changelog": "^1.2.2",
    "grunt-eslint": "^14.0.0",
    "grunt-npm": "^0.0.2",
    "grunt-simple-mocha": "^0.4.0",
    "karma": "^0.12.0",
    "load-grunt-tasks": "^3.2.0",
    "lodash": "^3.9.3",
    "mocks": "0.0.11",
    "sinon": "^1.14.1",
    "sinon-chai": "^2.8.0"
  },
  "homepage": "https://github.com/karma-runner/karma-coverage#readme",
  "keywords": [
    "coverage",
    "istanbul",
    "karma-plugin",
    "karma-preprocessor",
    "karma-reporter"
  ],
  "license": "MIT",
  "main": "lib/index.js",
  "name": "karma-coverage",
  "optionalDependencies": {},
  "readme": "# karma-coverage\n\n[![js-standard-style](https://img.shields.io/badge/code%20style-standard-brightgreen.svg?style=flat-square)](https://github.com/karma-runner/karma-coverage)\n [![npm version](https://img.shields.io/npm/v/karma-coverage.svg?style=flat-square)](https://www.npmjs.com/package/karma-coverage) [![npm downloads](https://img.shields.io/npm/dm/karma-coverage.svg?style=flat-square)](https://www.npmjs.com/package/karma-coverage)\n\n[![Build Status](https://img.shields.io/travis/karma-runner/karma-coverage/master.svg?style=flat-square)](https://travis-ci.org/karma-runner/karma-coverage) [![Dependency Status](https://img.shields.io/david/karma-runner/karma-coverage.svg?style=flat-square)](https://david-dm.org/karma-runner/karma-coverage) [![devDependency Status](https://img.shields.io/david/dev/karma-runner/karma-coverage.svg?style=flat-square)](https://david-dm.org/karma-runner/karma-coverage#info=devDependencies)\n\n> Generate code coverage using [Istanbul].\n\n## Installation\n\nThe easiest way is to install `karma-coverage` as a `devDependency`,\nby running\n\n```bash\nnpm install karma karma-coverage --save-dev\n```\n\n## Configuration\n\nThe following code shows a simple usage:\n\n```javascript\n// karma.conf.js\nmodule.exports = function(config) {\n  config.set({\n    files: [\n      'src/**/*.js',\n      'test/**/*.js'\n    ],\n\n    // coverage reporter generates the coverage\n    reporters: ['progress', 'coverage'],\n\n    preprocessors: {\n      // source files, that you wanna generate coverage for\n      // do not include tests or libraries\n      // (these files will be instrumented by Istanbul)\n      'src/**/*.js': ['coverage']\n    },\n\n    // optionally, configure the reporter\n    coverageReporter: {\n      type : 'html',\n      dir : 'coverage/'\n    }\n  });\n};\n```\n\nExample use with a CoffeeScript project:\n\n```javascript\n// karma.conf.js\nmodule.exports = function(config) {\n  config.set({\n    files: [\n      'src/**/*.coffee',\n      'test/**/*.coffee'\n    ],\n\n    // coverage reporter generates the coverage\n    reporters: ['progress', 'coverage'],\n\n    preprocessors: {\n      // source files, that you wanna generate coverage for\n      // do not include tests or libraries\n      // (these files will be instrumented by Istanbul via Ibrik unless\n      // specified otherwise in coverageReporter.instrumenter)\n      'src/**/*.coffee': ['coverage'],\n\n      // note: project files will already be converted to\n      // JavaScript via coverage preprocessor.\n      // Thus, you'll have to limit the CoffeeScript preprocessor\n      // to uncovered files.\n      'test/**/*.coffee': ['coffee']\n    },\n\n    // optionally, configure the reporter\n    coverageReporter: {\n      type : 'html',\n      dir : 'coverage/'\n    }\n  });\n};\n```\n\nHere is an advanced usage of karma-coverage, using severals reporters:\n\n```javascript\n// karma.conf.js\nmodule.exports = function(config) {\n  config.set({\n    files: [\n      'src/**/*.js',\n      'test/**/*.js'\n    ],\n    reporters: ['progress', 'coverage'],\n    preprocessors: {\n      'src/**/*.js': ['coverage']\n    },\n    coverageReporter: {\n      // specify a common output directory\n      dir: 'build/reports/coverage',\n      reporters: [\n        // reporters not supporting the `file` property\n        { type: 'html', subdir: 'report-html' },\n        { type: 'lcov', subdir: 'report-lcov' },\n        // reporters supporting the `file` property, use `subdir` to directly\n        // output them in the `dir` directory\n        { type: 'cobertura', subdir: '.', file: 'cobertura.txt' },\n        { type: 'lcovonly', subdir: '.', file: 'report-lcovonly.txt' },\n        { type: 'teamcity', subdir: '.', file: 'teamcity.txt' },\n        { type: 'text', subdir: '.', file: 'text.txt' },\n        { type: 'text-summary', subdir: '.', file: 'text-summary.txt' },\n      ]\n    }\n  });\n});\n```\n\n### Options\n#### type\n**Type:** String\n\n**Description:** Specify a reporter type.\n\n**Possible Values:**\n  * `html` (default)\n  * `lcov` (lcov and html)\n  * `lcovonly`\n  * `text`\n  * `text-summary`\n  * `cobertura` (xml format supported by Jenkins)\n  * `teamcity` (code coverage System Messages for TeamCity)\n  * `json` (json format supported by [`grunt-istanbul-coverage`](https://github.com/daniellmb/grunt-istanbul-coverage))\n\n#### dir\n**Type:** String\n\n**Description:** This will be used to output coverage reports. When\n  you set a relative path, the directory is resolved against the `basePath`.\n\n#### subdir\n**Type:** String\n\n**Description**: This will be used in complement of the `coverageReporter.dir`\noption to generate the full output directory path. By default, the output\ndirectory is set to `./config.dir/BROWSER_NAME/`, this option allows you to\ncustom the second part. You can either pass a `string` or a `function` which will be\ncalled with the browser name passed as the only argument.\n\n```javascript\ncoverageReporter: {\n  dir: 'coverage',\n  subdir: '.'\n  // Would output the results into: .'/coverage/'\n}\n```\n\n```javascript\ncoverageReporter: {\n  dir: 'coverage',\n  subdir: 'report'\n  // Would output the results into: .'/coverage/report/'\n}\n```\n\n```javascript\ncoverageReporter: {\n  dir: 'coverage',\n  subdir: function(browser) {\n    // normalization process to keep a consistent browser name accross different\n    // OS\n    return browser.toLowerCase().split(/[ /-]/)[0];\n  }\n  // Would output the results into: './coverage/firefox/'\n}\n```\n\n#### file\n\nIf you choose the `cobertura`, `lcovonly`, `teamcity`, `text` or `text-summary` reporters, you may set the `file` option to specify an output file.\n\n```javascript\ncoverageReporter: {\n  type : 'text',\n  dir : 'coverage/',\n  file : 'coverage.txt'\n}\n```\n\n#### check\n**Type:** Object\n\n**Description:** This will be used to configure minimum threshold enforcement for coverage results. If the thresholds are not met, karma will return failure. Thresholds, when specified as a positive number are taken to be the minimum percentage required. When a threshold is specified as a negative number it represents the maximum number of uncovered entities allowed.\n\nFor example, `statements: 90` implies minimum statement coverage is 90%. `statements: -10` implies that no more than 10 uncovered statements are allowed.\n\n`global` applies to all files together and `each` on a per-file basis. A list of files or patterns can be excluded from enforcement via the `exclude` property. On a per-file or pattern basis, per-file thresholds can be overridden via the `overrides` property.\n\n```javascript\ncoverageReporter: {\n  check: {\n    global: {\n      statements: 50,\n      branches: 50,\n      functions: 50,\n      lines: 50,\n      excludes: [\n        'foo/bar/**/*.js'\n      ]\n    },\n    each: {\n      statements: 50,\n      branches: 50,\n      functions: 50,\n      lines: 50,\n      excludes: [\n        'other/directory/**/*.js'\n      ],\n      overrides: {\n        'baz/component/**/*.js': {\n          statements: 98\n        }\n      }\n    }\n  }\n}\n```\n\n#### watermarks\n**Type:** Object\n\n**Description:** This will be used to set the coverage threshold colors. The first number is the threshold between Red and Yellow. The second number is the threshold between Yellow and Green.\n\n```javascript\ncoverageReporter: {\n  watermarks: {\n    statements: [ 50, 75 ],\n    functions: [ 50, 75 ],\n    branches: [ 50, 75 ],\n    lines: [ 50, 75 ]\n  }\n}\n```\n\n#### includeAllSources\n**Type:** Boolean\n\nYou can opt to include all sources files, as indicated by the coverage preprocessor, in your code coverage data, even if there are no tests covering them. (Default `false`)\n\n```javascript\ncoverageReporter: {\n  type : 'text',\n  dir : 'coverage/',\n  file : 'coverage.txt',\n  includeAllSources: true\n}\n```\n\n#### sourceStore\n**Type:** istanbul.Store\n\nYou can opt to specify a source store allowing for external coverage collectors access to the instrumented code.\n\n```javascript\ncoverageReporter: {\n  type : 'text',\n  dir : 'coverage/',\n  file : 'coverage.txt',\n  sourceStore : require('istanbul').Store.create('fslookup')\n}\n```\n\n#### multiple reporters\nYou can use multiple reporters, by providing array of options.\n\n```javascript\ncoverageReporter: {\n  reporters:[\n    {type: 'html', dir:'coverage/'},\n    {type: 'teamcity'},\n    {type: 'text-summary'}\n  ],\n}\n```\n\n#### instrumenter\nKarma-coverage can infers the instrumenter regarding of the file extension.\n  It is possible to override this behavior and point out an\n  instrumenter for the files matching a specific pattern.\n  To do so, you need to declare an object under with the keys represents the\n  pattern to match, and the instrumenter to apply. The matching will be done\n  using [minimatch](https://github.com/isaacs/minimatch).\n  If two patterns match, the last one will take the precedence.\n\nFor example you can use [Ibrik](https://github.com/Constellation/ibrik) (an\n  [Istanbul](https://github.com/gotwarlost/istanbul) analog for\n  CoffeeScript files) with:\n\n```javascript\ncoverageReporter: {\n  instrumenters: { ibrik : require('ibrik') }\n  instrumenter: {\n    '**/*.coffee': 'ibrik'\n  },\n  // ...\n}\n```\n\nYou can pass options additional options to specific instrumenter with:\n\n```javascript\nvar to5Options = { experimental: true };\n\n// [...]\n\ncoverageReporter: {\n  instrumenters: { isparta : require('isparta') },\n  instrumenter: {\n    '**/*.js': 'isparta'\n  },\n  instrumenterOptions: {\n    isparta: { to5 : to5Options }\n  }\n}\n```\n\n\n----\n\nFor more information on Karma see the [homepage].\n\n\n[homepage]: http://karma-runner.github.com\n[Istanbul]: https://github.com/gotwarlost/istanbul\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/karma-runner/karma-coverage.git"
  },
  "scripts": {
    "test": "grunt test"
  },
  "version": "0.4.1"
}
